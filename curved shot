-- Variables
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local UserInputService = game:GetService("UserInputService")
local proximityThreshold = 10 -- Distance from the opponent to trigger the movement copying
local isActive = false -- Toggle state for the V key (on or off)

-- Function to detect the closest opponent (assumes opponents are other players)
local function getClosestOpponent()
    local closestOpponent = nil
    local closestDistance = math.huge

    for _, opponent in pairs(game.Players:GetPlayers()) do
        if opponent ~= player then
            local opponentCharacter = opponent.Character
            if opponentCharacter and opponentCharacter:FindFirstChild("HumanoidRootPart") then
                local distance = (mouse.Hit.p - opponentCharacter.HumanoidRootPart.Position).magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestOpponent = opponent
                end
            end
        end
    end
    return closestOpponent, closestDistance
end

-- Function to check for walls or obstacles (simple raycast)
local function hasObstacleInDirection(direction)
    local rayOrigin = player.Character.HumanoidRootPart.Position
    local rayDirection = direction * 5 -- Check 5 studs ahead
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local rayResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    return rayResult ~= nil -- Return true if there's an obstacle
end

-- Function to replicate a "peek" movement based on opponent's position
local function peekMovement(opponent)
    if opponent and opponent.Character then
        local opponentRootPart = opponent.Character:FindFirstChild("HumanoidRootPart")
        local playerRootPart = player.Character:FindFirstChild("HumanoidRootPart")

        if opponentRootPart and playerRootPart then
            local opponentDirection = opponentRootPart.CFrame.LookVector -- Where opponent is facing
            local playerDirection = playerRootPart.CFrame.LookVector

            -- Calculate direction to move, you can add randomness or alternative logic here
            if not hasObstacleInDirection(opponentDirection) then
                -- If no obstacle, move in the same direction as the opponent
                playerRootPart.CFrame = playerRootPart.CFrame + (opponentDirection * 3) -- Move 3 studs forward
            else
                -- If there's an obstacle, try moving in the opposite direction (mirroring)
                local oppositeDirection = -opponentDirection
                if not hasObstacleInDirection(oppositeDirection) then
                    playerRootPart.CFrame = playerRootPart.CFrame + (oppositeDirection * 3)
                end
            end
        end
    end
end

-- Toggle the mode with the V key
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent then
        if input.KeyCode == Enum.KeyCode.V then
            isActive = not isActive -- Toggle the active state
            print("Peek mode: " .. (isActive and "Activated" or "Deactivated"))
        end
    end
end)

-- Main loop to check for peeking movements when the mode is active
game:GetService("RunService").Heartbeat:Connect(function()
    if isActive then
        -- Get the closest opponent
        local closestOpponent, distance = getClosestOpponent()

        -- Check if the mouse is near the opponent and react
        if closestOpponent and distance <= proximityThreshold then
            peekMovement(closestOpponent)
        end
    end
end)
